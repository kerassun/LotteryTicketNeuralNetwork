# -*- coding: utf-8 -*-
"""ThePickLottery-NeuralNetworkipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mFC9X1v-xX53Gt5yc78yFlyMqFYcg7EP

## Import All Libraries Needed for Neural Network
"""

import datetime
import tensorflow as tf
import os
print(tf.__version__)
import IPython
import IPython.display

from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping
from tensorflow import keras
from tensorflow.keras.layers import Input, Dense
from tensorflow.keras.optimizers import Adam

import pandas as pd

import sklearn
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import math

mpl.rcParams["figure.figsize"] = (8,8)
mpl.rcParams["axes.grid"] = False

device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
  raise SystemError("GPU device not found")
print(f"Found GPU at {device_name}")

"""## Importing The Dataset and Cleaning The Data"""

df = pd.read_csv("/content/1984-2022_combined_the_pick_lottery.csv", names=["draw-date", "no1", "no2", "no3", "no4", "no5", "no6"], parse_dates=True)

df.head()

df.drop([0], inplace=True)

df.head()

date_df = df["draw-date"].str.split(" ", expand=True)

df.insert(0, "date", date_df[1])

df.head()

df.drop(["draw-date"], axis=1, inplace=True)

df.head()

df["date"] = df["date"].astype("datetime64[ns]")

df.head()

df["no1"] = df["no1"].astype(int)
df["no2"] = df["no2"].astype(int)
df["no3"] = df["no3"].astype(int)
df["no4"] = df["no4"].astype(int)
df["no5"] = df["no5"].astype(int)
df["no6"] = df["no6"].astype(int)

df.sort_values(["date"], ascending=False, inplace=True)

df.set_index(["date"], inplace=True, drop=True)

df.head()

"""## Creating The Nearual Network"""

df.plot()

n = len(df)
train_df = df[0:int(n*0.7)]
val_df = df[int(n*0.7):int(n*0.9)]
test_df = df[int(n*0.9):]
num_features = df.shape[:]

train_mean = train_df.mean()
train_std = train_df.std()
train_df_norm = (train_df - train_mean) / train_std
val_df_norm = (val_df - train_mean) / train_std
test_df_norm = (test_df - train_mean) / train_std
train_df_norm

class WindowGenerator():
  def __init__(self, input_width, label_width, shift,
               train_df=train_df, val_df=val_df, test_df=test_df,
               label_columns=None):
    # Store the raw data.
    self.train_df = train_df
    self.val_df = val_df
    self.test_df = test_df

    # Work out the label column indices.
    self.label_columns = label_columns
    if label_columns is not None:
      self.label_columns_indices = {name: i for i, name in
                                    enumerate(label_columns)}
    self.column_indices = {name: i for i, name in
                           enumerate(train_df.columns)}

    # Work out the window parameters.
    self.input_width = input_width
    self.label_width = label_width
    self.shift = shift

    self.total_window_size = input_width + shift

    self.input_slice = slice(0, input_width)
    self.input_indices = np.arange(self.total_window_size)[self.input_slice]

    self.label_start = self.total_window_size - self.label_width
    self.labels_slice = slice(self.label_start, None)
    self.label_indices = np.arange(self.total_window_size)[self.labels_slice]

  def __repr__(self):
    return '\n'.join([
        f'Total window size: {self.total_window_size}',
        f'Input indices: {self.input_indices}',
        f'Label indices: {self.label_indices}',
        f'Label column name(s): {self.label_columns}'])

MAX_EPOCHS = 10

def compile_and_fit(model, window, patience=2): 
  # early_stopping = tf.keras.callbacks.EarlyStopping(monitor="val_loss",
  #                                                            "patience=patience",
  #                                                             mode="min")

  model.compile(loss=tf.keras.losses.MeanSquaredError(),
                optimizer=tf.keras.optimizers.SGD(learning_rate=0.0001),
                metrics=[tf.keras.metrics.MeanAbsoluteError()])
  
  history = model.fit(window.train, epochs=MAX_EPOCHS,
                      validation_data=window.val,
                      # callbacks=[early_stopping]
                      )
  return history

def make_dataset(self, data):
  data = np.array(data, dtype=np.float32)
  ds = tf.keras.utils.timeseries_dataset_from_array(
      data=data,
      targets=None,
      sequence_length=self.total_window_size,
      sequence_stride=1,
      shuffle=True,
      batch_size=32,)

  ds = ds.map(self.split_window)

  return ds

WindowGenerator.make_dataset = make_dataset

@property
def train(self):
  return self.make_dataset(self.train_df)

@property
def val(self):
  return self.make_dataset(self.val_df)

@property
def test(self):
  return self.make_dataset(self.test_df)

@property
def example(self):
  """Get and cache an example batch of `inputs, labels` for plotting."""
  result = getattr(self, '_example', None)
  if result is None:
    # No example batch was found, so get one from the `.train` dataset
    result = next(iter(self.train))
    # And cache it for next time
    self._example = result
  return result

WindowGenerator.train = train
WindowGenerator.val = val
WindowGenerator.test = test
WindowGenerator.example = example

def split_window(self, features):
  inputs = features[:, self.input_slice, :]
  labels = features[:, self.labels_slice, :]
  if self.label_columns is not None:
    labels = tf.stack(
        [labels[:, :, self.column_indices[name]] for name in self.label_columns],
        axis=-1)

  # Slicing doesn't preserve static shape information, so set the shapes
  # manually. This way the `tf.data.Datasets` are easier to inspect.
  inputs.set_shape([None, self.input_width, None])
  labels.set_shape([None, self.label_width, None])

  return inputs, labels

WindowGenerator.split_window = split_window

def plot(self, model=None, max_subplots=6):
  plot_col=["no1", "no2", "no3", "no4", "no5", "no6"]
  inputs, labels = self.example
  plt.figure(figsize=(12,8))
  max_n = min(max_subplots, len(inputs))
  for n in range(max_n):
    plot_col_index = self.column_indices[plot_col[n]]
    plt.subplot(6, 1, n+1)
    plt.ylabel(f"{plot_col[n]}")
    plt.plot(self.input_indices, inputs[n, :, plot_col_index],
             label="Inputs", marker=".", zorder=-10)
    
    if self.label_columns:
      label_col_index = self.label_column_indices.get(plot_col, None)
    else:
      label_col_index = plot_col_index

    if label_col_index == None:
      continue

    plt.scatter(self.label_indices, labels[n, :, label_col_index],
                edgecolors="k", label="Labels", c="#2ca02c", s=64)
    
    if model is not None:
      predictions = model(inputs)
      plt.scatter(self.label_indices, predictions[n, :, label_col_index],
                  marker="X", edgecolors="k", label="Predictions",
                  c="#ff7f0e", s=64)
      
    if n == 0:
      plt.legend()

  plt.xlabel("Time")
  return predictions, labels

WindowGenerator.plot = plot

single_step_window = WindowGenerator(
    # `WindowGenerator` returns all features as labels if you 
    # don't set the `label_columns` argument.
    input_width=1, label_width=1, shift=1)

wide_window = WindowGenerator(
    input_width=24, label_width=24, shift=1)

single_val_performance = {}
single_performance = {}
val_performance = {}
performance = {}

class Baseline(tf.keras.Model):
  def __init__(self, label_index=None):
    super().__init__()
    self.label_index = label_index

  def call(self, inputs):
    if self.label_index is None:
      return inputs
    result = inputs[:, :, self.label_index]
    return result[:, :, tf.newaxis]

baseline = Baseline()
_ = compile_and_fit(baseline, single_step_window)


IPython.display.clear_output()
single_val_performance["Baseline"] = baseline.evaluate(single_step_window.val)
single_performance["Baseline"] = baseline.evaluate(single_step_window.test, verbose=1)
val_performance["Baseline"] = single_val_performance["Baseline"]
performance["Baseline"] = single_performance["Baseline"]

dense_ANN = tf.keras.models.Sequential([
  tf.keras.layers.Dense(units=10),
  tf.keras.layers.Dense(units=6)
])

history = compile_and_fit(dense_ANN, single_step_window)
IPython.display.clear_output()
single_val_performance["Dense"] = dense_ANN.evaluate(single_step_window.val)
single_performance["Dense"] = dense_ANN.evaluate(single_step_window.test, verbose=1)

history = history.history

history.keys()

plt.plot(history["loss"], label="train_loss")
plt.plot(history["val_loss"], label="val_loss")
plt.legend()
plt.show()

single_step_window.total_window_size

example_window = tf.stack([np.array(train_df[:single_step_window.total_window_size]),
                           np.array(train_df[2:2+single_step_window.total_window_size]),
                           np.array(train_df[4:4+single_step_window.total_window_size]),
                           np.array(train_df[6:6+single_step_window.total_window_size]),
                           np.array(train_df[8:8+single_step_window.total_window_size]),
                           np.array(train_df[10:10+single_step_window.total_window_size])])

example_window.shape

example_inputs, example_labels = single_step_window.split_window(example_window)

single_step_window.other = example_inputs, example_labels

predictions = wide_window.plot(dense_ANN)

x = np.arange(len(single_val_performance))
width = 0.3
metric_name = 'mean_absolute_error'
metric_index = dense_ANN.metrics_names.index('mean_absolute_error')
val_mae = [v[metric_index] for v in single_val_performance.values()]
test_mae = [v[metric_index] for v in single_performance.values()]

plt.title("Single-Step Model Error Comparison")
plt.ylabel("mean_absolute_error [no1-no6, normalized]")
plt.bar(x - 0.17, val_mae, width, label="Validation")
plt.bar(x + 0.17, test_mae, label="Test")
plt.xticks(ticks=x, labels=single_performance.keys(),
           rotation=45)
_ = plt.legend()

inputs = df[["no1","no2","no3","no4","no5","no6"]].iloc[1]

data_mean = df.mean()
data_std = df.std()

inputs_norm = (inputs - data_mean) / data_std

new_arr = np.expand_dims(inputs_norm, axis=0)

pred_norm = dense_ANN.predict(new_arr).astype(int)

pred = (pred_norm[0] * data_std) + data_mean

np.floor(pred).astype(int)

"""# Comparing prediction numbers to all drawn numbers from dataset."""

# Purchased Numbers: 7, 12, 19, 25, 31, 37
# Predition Numbers: 6, 12, 18, 24, 37, 43
# Winning Lottery Numbers Example: 11, 14, 15, 22, 27, 38
def findWinner(thresh):
  prediction_numbers = [7, 13, 16, 24, 35, 42]
  filtered_pred_csv = df[:].isin(prediction_numbers)
  filtered_dataframe = df[filtered_pred_csv]
  drop_na_list = filtered_dataframe.dropna(thresh=thresh)
  print(drop_na_list)
findWinner(4)

